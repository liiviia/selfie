{"ast":null,"code":"import axios from 'axios'; // Importa Axios\nimport moment from 'moment-timezone';\nexport default {\n  data() {\n    return {\n      intervalId: null // Per memorizzare l'ID dell'intervallo\n    };\n  },\n  created() {\n    const timeMachine = async () => {\n      try {\n        const response = await axios.get('/api/getTime-machine');\n        console.log(\"get time machine\", response.data);\n        const localDate = moment(response.data.date).tz('Europe/Rome', true).format();\n        console.log(\"Data convertita nel fuso orario locale:\", localDate);\n      } catch (error) {\n        console.error('Errore nella richiesta GET:', error);\n      }\n    };\n    const fetchAlerts = async () => {\n      try {\n        const loggedInUser = localStorage.getItem('username');\n\n        // Utilizza Axios per fare la richiesta GET\n        const response = await axios.get(`/alerts?userNome=${loggedInUser}`);\n        console.log(\"Risposta Axios:\", response);\n        if (response.data && Array.isArray(response.data) && response.data.length > 0) {\n          // Quando ci sono notifiche, visualizzale subito come alert()\n          response.data.forEach(alert => {\n            alert(`TITOLO: ${alert.title}\\nData: ${alert.date}\\nOra di inizio: ${alert.startTime}`);\n          });\n        } else {\n          console.log('Nessuna notifica per l\\'utente');\n        }\n      } catch (error) {\n        // Gestisci gli errori\n        console.error('Errore nella richiesta Axios:', error);\n      }\n    };\n\n    // Esegui `fetchAlerts` ogni secondo\n    this.intervalId = setInterval(fetchAlerts, timeMachine, 1000); // 1000ms = 1 secondo\n  },\n  beforeUnmount() {\n    // Quando il componente viene distrutto, cancella l'intervallo\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n};","map":{"version":3,"names":["axios","moment","data","intervalId","created","timeMachine","response","get","console","log","localDate","date","tz","format","error","fetchAlerts","loggedInUser","localStorage","getItem","Array","isArray","length","forEach","alert","title","startTime","setInterval","beforeUnmount","clearInterval"],"sources":["/home/massi1/Documenti/uni/tecWEB/progettoClone/progettoTWvue/frontend/src/components/NotificationComponent.vue"],"sourcesContent":["<template>\n  <div>\n    <!-- Non Ã¨ necessario visualizzare notifiche in una lista, ma si possono processare qui -->\n  </div>\n</template>\n\n<script>\nimport axios from 'axios'; // Importa Axios\nimport moment from 'moment-timezone';\n\nexport default {\n  data() {\n    return {\n      intervalId: null, // Per memorizzare l'ID dell'intervallo\n    };\n  },\n  created() {\n    \n\nconst timeMachine = async () => {\n  try {\n        const response = await axios.get('/api/getTime-machine'); \n        console.log(\"get time machine\", response.data);\n\n        const localDate = moment(response.data.date).tz('Europe/Rome', true).format();\n        console.log(\"Data convertita nel fuso orario locale:\", localDate);\n    } catch (error) {\n        console.error('Errore nella richiesta GET:', error);\n    }\n\n};\n    const fetchAlerts = async () => {\n      try {\n        const loggedInUser = localStorage.getItem('username');\n\n        // Utilizza Axios per fare la richiesta GET\n        const response = await axios.get(`/alerts?userNome=${loggedInUser}`);\n        console.log(\"Risposta Axios:\", response);\n\n        if (response.data && Array.isArray(response.data) && response.data.length > 0) {\n          // Quando ci sono notifiche, visualizzale subito come alert()\n          response.data.forEach(alert => {\n            alert(`TITOLO: ${alert.title}\\nData: ${alert.date}\\nOra di inizio: ${alert.startTime}`);\n          });\n        } else {\n          console.log('Nessuna notifica per l\\'utente');\n        }\n      } catch (error) {\n        // Gestisci gli errori\n        console.error('Errore nella richiesta Axios:', error);\n      }\n    };\n\n    // Esegui `fetchAlerts` ogni secondo\n    this.intervalId = setInterval(fetchAlerts, timeMachine, 1000); // 1000ms = 1 secondo\n  },\n\n  beforeUnmount() {\n    // Quando il componente viene distrutto, cancella l'intervallo\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  },\n};\n</script>\n\n<style scoped>\n/* Stilizzazione personalizzata, se necessaria */\n</style>\n"],"mappings":"AAOA,OAAOA,KAAI,MAAO,OAAO,EAAE;AAC3B,OAAOC,MAAK,MAAO,iBAAiB;AAEpC,eAAe;EACbC,IAAIA,CAAA,EAAG;IACL,OAAO;MACLC,UAAU,EAAE,IAAI,CAAE;IACpB,CAAC;EACH,CAAC;EACDC,OAAOA,CAAA,EAAG;IAGZ,MAAMC,WAAU,GAAI,MAAAA,CAAA,KAAY;MAC9B,IAAI;QACE,MAAMC,QAAO,GAAI,MAAMN,KAAK,CAACO,GAAG,CAAC,sBAAsB,CAAC;QACxDC,OAAO,CAACC,GAAG,CAAC,kBAAkB,EAAEH,QAAQ,CAACJ,IAAI,CAAC;QAE9C,MAAMQ,SAAQ,GAAIT,MAAM,CAACK,QAAQ,CAACJ,IAAI,CAACS,IAAI,CAAC,CAACC,EAAE,CAAC,aAAa,EAAE,IAAI,CAAC,CAACC,MAAM,CAAC,CAAC;QAC7EL,OAAO,CAACC,GAAG,CAAC,yCAAyC,EAAEC,SAAS,CAAC;MACrE,EAAE,OAAOI,KAAK,EAAE;QACZN,OAAO,CAACM,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;MACvD;IAEJ,CAAC;IACG,MAAMC,WAAU,GAAI,MAAAA,CAAA,KAAY;MAC9B,IAAI;QACF,MAAMC,YAAW,GAAIC,YAAY,CAACC,OAAO,CAAC,UAAU,CAAC;;QAErD;QACA,MAAMZ,QAAO,GAAI,MAAMN,KAAK,CAACO,GAAG,CAAC,oBAAoBS,YAAY,EAAE,CAAC;QACpER,OAAO,CAACC,GAAG,CAAC,iBAAiB,EAAEH,QAAQ,CAAC;QAExC,IAAIA,QAAQ,CAACJ,IAAG,IAAKiB,KAAK,CAACC,OAAO,CAACd,QAAQ,CAACJ,IAAI,KAAKI,QAAQ,CAACJ,IAAI,CAACmB,MAAK,GAAI,CAAC,EAAE;UAC7E;UACAf,QAAQ,CAACJ,IAAI,CAACoB,OAAO,CAACC,KAAI,IAAK;YAC7BA,KAAK,CAAC,WAAWA,KAAK,CAACC,KAAK,WAAWD,KAAK,CAACZ,IAAI,oBAAoBY,KAAK,CAACE,SAAS,EAAE,CAAC;UACzF,CAAC,CAAC;QACJ,OAAO;UACLjB,OAAO,CAACC,GAAG,CAAC,gCAAgC,CAAC;QAC/C;MACF,EAAE,OAAOK,KAAK,EAAE;QACd;QACAN,OAAO,CAACM,KAAK,CAAC,+BAA+B,EAAEA,KAAK,CAAC;MACvD;IACF,CAAC;;IAED;IACA,IAAI,CAACX,UAAS,GAAIuB,WAAW,CAACX,WAAW,EAAEV,WAAW,EAAE,IAAI,CAAC,EAAE;EACjE,CAAC;EAEDsB,aAAaA,CAAA,EAAG;IACd;IACA,IAAI,IAAI,CAACxB,UAAU,EAAE;MACnByB,aAAa,CAAC,IAAI,CAACzB,UAAU,CAAC;IAChC;EACF;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}