{"ast":null,"code":"export default {\n  data() {\n    return {\n      intervalId: null // Per memorizzare l'ID dell'intervallo\n    };\n  },\n  created() {\n    const fetchAlerts = async () => {\n      try {\n        const loggedInUser = localStorage.getItem('username');\n        const response = await fetch(`/alerts?userNome=${loggedInUser}`);\n        if (response.ok) {\n          // Verifica se la risposta è vuota\n          const text = await response.text(); // Ottieni la risposta come testo\n\n          if (text.trim() === \"\") {\n            console.log('Nessuna notifica disponibile per l\\'utente');\n            return; // Se la risposta è vuota, non fare nulla\n          }\n\n          // Controlla che la risposta sia in formato JSON\n          const contentType = response.headers.get(\"content-type\");\n          if (contentType && contentType.includes(\"application/json\")) {\n            const newAlerts = JSON.parse(text);\n            if (Array.isArray(newAlerts) && newAlerts.length > 0) {\n              // Quando ci sono notifiche, visualizzale subito come alert()\n              newAlerts.forEach(alert => {\n                alert(`TITOLO: ${alert.title}\\nData: ${alert.date}\\nOra di inizio: ${alert.startTime}`);\n              });\n            } else {\n              console.log('Nessuna notifica per l\\'utente');\n            }\n          } else {\n            console.error('La risposta del server non è in formato JSON');\n          }\n        } else {\n          console.error('Errore nella richiesta:', response.statusText);\n        }\n      } catch (error) {\n        console.error('Errore nella richiesta:', error);\n      }\n    };\n\n    // Esegui `fetchAlerts` ogni secondo\n    this.intervalId = setInterval(fetchAlerts, 1000); // 1000ms = 1 secondo\n  },\n  beforeDestroy() {\n    // Quando il componente viene distrutto, cancella l'intervallo\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n};","map":{"version":3,"names":["data","intervalId","created","fetchAlerts","loggedInUser","localStorage","getItem","response","fetch","ok","text","trim","console","log","contentType","headers","get","includes","newAlerts","JSON","parse","Array","isArray","length","forEach","alert","title","date","startTime","error","statusText","setInterval","beforeDestroy","clearInterval"],"sources":["/home/massi1/Documenti/uni/tecWEB/progettoClone/progettoTWvue/frontend/src/components/NotificationComponent.vue"],"sourcesContent":["<template>\n  <div>\n    <!-- Non è necessario visualizzare notifiche in una lista, ma si possono processare qui -->\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      intervalId: null, // Per memorizzare l'ID dell'intervallo\n    };\n  },\n  created() {\n    const fetchAlerts = async () => {\n      try {\n        const loggedInUser = localStorage.getItem('username');\n        const response = await fetch(`/alerts?userNome=${loggedInUser}`);\n\n        if (response.ok) {\n          // Verifica se la risposta è vuota\n          const text = await response.text(); // Ottieni la risposta come testo\n\n          if (text.trim() === \"\") {\n            console.log('Nessuna notifica disponibile per l\\'utente');\n            return; // Se la risposta è vuota, non fare nulla\n          }\n\n          // Controlla che la risposta sia in formato JSON\n          const contentType = response.headers.get(\"content-type\");\n          if (contentType && contentType.includes(\"application/json\")) {\n            const newAlerts = JSON.parse(text);\n\n            if (Array.isArray(newAlerts) && newAlerts.length > 0) {\n              // Quando ci sono notifiche, visualizzale subito come alert()\n              newAlerts.forEach(alert => {\n                alert(`TITOLO: ${alert.title}\\nData: ${alert.date}\\nOra di inizio: ${alert.startTime}`);\n              });\n            } else {\n              console.log('Nessuna notifica per l\\'utente');\n            }\n          } else {\n            console.error('La risposta del server non è in formato JSON');\n          }\n        } else {\n          console.error('Errore nella richiesta:', response.statusText);\n        }\n      } catch (error) {\n        console.error('Errore nella richiesta:', error);\n      }\n    };\n\n    // Esegui `fetchAlerts` ogni secondo\n    this.intervalId = setInterval(fetchAlerts, 1000); // 1000ms = 1 secondo\n  },\n  beforeDestroy() {\n    // Quando il componente viene distrutto, cancella l'intervallo\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  },\n};\n</script>\n\n<style scoped>\n/* Stilizzazione personalizzata, se necessaria */\n</style>\n"],"mappings":"AAOA,eAAe;EACbA,IAAIA,CAAA,EAAG;IACL,OAAO;MACLC,UAAU,EAAE,IAAI,CAAE;IACpB,CAAC;EACH,CAAC;EACDC,OAAOA,CAAA,EAAG;IACR,MAAMC,WAAU,GAAI,MAAAA,CAAA,KAAY;MAC9B,IAAI;QACF,MAAMC,YAAW,GAAIC,YAAY,CAACC,OAAO,CAAC,UAAU,CAAC;QACrD,MAAMC,QAAO,GAAI,MAAMC,KAAK,CAAC,oBAAoBJ,YAAY,EAAE,CAAC;QAEhE,IAAIG,QAAQ,CAACE,EAAE,EAAE;UACf;UACA,MAAMC,IAAG,GAAI,MAAMH,QAAQ,CAACG,IAAI,CAAC,CAAC,EAAE;;UAEpC,IAAIA,IAAI,CAACC,IAAI,CAAC,MAAM,EAAE,EAAE;YACtBC,OAAO,CAACC,GAAG,CAAC,4CAA4C,CAAC;YACzD,OAAM,CAAE;UACV;;UAEA;UACA,MAAMC,WAAU,GAAIP,QAAQ,CAACQ,OAAO,CAACC,GAAG,CAAC,cAAc,CAAC;UACxD,IAAIF,WAAU,IAAKA,WAAW,CAACG,QAAQ,CAAC,kBAAkB,CAAC,EAAE;YAC3D,MAAMC,SAAQ,GAAIC,IAAI,CAACC,KAAK,CAACV,IAAI,CAAC;YAElC,IAAIW,KAAK,CAACC,OAAO,CAACJ,SAAS,KAAKA,SAAS,CAACK,MAAK,GAAI,CAAC,EAAE;cACpD;cACAL,SAAS,CAACM,OAAO,CAACC,KAAI,IAAK;gBACzBA,KAAK,CAAC,WAAWA,KAAK,CAACC,KAAK,WAAWD,KAAK,CAACE,IAAI,oBAAoBF,KAAK,CAACG,SAAS,EAAE,CAAC;cACzF,CAAC,CAAC;YACJ,OAAO;cACLhB,OAAO,CAACC,GAAG,CAAC,gCAAgC,CAAC;YAC/C;UACF,OAAO;YACLD,OAAO,CAACiB,KAAK,CAAC,8CAA8C,CAAC;UAC/D;QACF,OAAO;UACLjB,OAAO,CAACiB,KAAK,CAAC,yBAAyB,EAAEtB,QAAQ,CAACuB,UAAU,CAAC;QAC/D;MACF,EAAE,OAAOD,KAAK,EAAE;QACdjB,OAAO,CAACiB,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;MACjD;IACF,CAAC;;IAED;IACA,IAAI,CAAC5B,UAAS,GAAI8B,WAAW,CAAC5B,WAAW,EAAE,IAAI,CAAC,EAAE;EACpD,CAAC;EACD6B,aAAaA,CAAA,EAAG;IACd;IACA,IAAI,IAAI,CAAC/B,UAAU,EAAE;MACnBgC,aAAa,CAAC,IAAI,CAAChC,UAAU,CAAC;IAChC;EACF;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}